[{"title":"Exception--The specified child already has a parent.","date":"2016-05-18T08:01:22.000Z","path":"2016/05/18/2016-05-18-Exception/","text":"1.此异常出现在对ViewPager设置Adapter的时候，在第二次设置的时候在instantiateItem函数中container调用addview，由于第二次调用意在刷新，并且该view不是new 出来的对象，由于用的是之前的view，所以在addView(view)的时候由于该view已经有parent，再次进行addview会抛出此异常。此时需要在调用addview()之前进行如下判断：ViewGroup parent = (ViewGroup) view.getParent();if (parent != null) { parent.removeAllViewsInLayout();}上段代码先判断是否有parent有的话移出所有view，然后再进行addView(view)既能解决该异常。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"EventBus了解","date":"2016-05-12T10:56:57.000Z","path":"2016/05/12/2016-05-12-EventBus/","text":"简介EventBus从字面意思来理解，事件总线。一个主要用于订阅、发布事件的总线。可以代替Intent,Handler,BroadCast在线程间传递消息。 Event:发布的事件,Post方法中为Object，说明可以为任意类型。 Subscriber：事件订阅者，接收Event 接收事件，由onEvent开头的函数来订阅。EventBus3.0以后通过注解方式来订阅，@Subscribe对方法进行注解即可订阅事件，方法名不需要以onEvent固定开头。接收方法运行线程有4中，3.0中在Annotation中的括号中以@Subscribe(threadMode = ?)来声明。threadmode有4中分别为ThreadMode.POSTING、ThreadMode.MAIN、ThreadMode.BACKGROUND、ThreadMode.ASYNC.Publisher:事件发布者，通过post()方法来发送事件。 发送事件，EventBus.getDefault().post(Object event)，来进行发送。使用注册EventBus的注册类似于Android中的广播，要注意register的同时进行ungister.方法如下： EventBus.getDefault().register(this);EventBus.getDefault().unregister(this);此段代码可以用在Activity、Fragment等的父类中，子类无需在进行注册，但是需要注意在3.0版本中需要在父类中声明一个带有注解空方法，否则如果子类中没有订阅会报找不到@Subscribe的错误，在3.0以下版本需要声明onEvent方法。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"事件分发机制分析","date":"2015-04-03T15:58:46.000Z","path":"2015/04/03/2015-04-03-事件分发机制分析/","text":"1.常见的MotionEvent MoutionEvent.ACTION_DOWN:按下 MotionEvent.ACTION_MOVE：移动 MotionEvent.ACTION_UP：抬起2.事件的分发事件的分发主要是View的事件分发，和ViewGroup的事件分发。 2.1. View的事件分发：先调用dispatchTouchEvent(MotionEvent ev)方法，接下来通过源码来分析一下View的dispatchTouchEvent（）这个方法。 if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } 上段为View的dispatch方法中的核心代码块，通过判断条件可以看到主要分三块mOnTouchListener，ENABLED，li.mOnTouchListener.onTouch(this, event)。这三个返回true则dispatch的result返回true,则不会走下方代码块，也不会执行onTouchEvent()方法。结论：当View设置了onTouchListener方法，并且返回true，如果此View是ENABLED则不会执行onTouchEvent（）方法.如果onTouch方法返回false，则调用onTouchEvent（）方法.下面再来看一段onTouchEvent()中的代码。 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } return true; } 通过这段代码可知如果没有设置onTouchListener或者返回false，在onTouchEvent()将会return true消耗掉此次事件，并且由上段代码可以看出PerformClick为对View点击事件的响应监听，由此可以的出结论：事件的触发顺序是先执行onTouch再执行onClick,并且如果onTouch返回true则将不会再执行onclick事件，返回false才会执行onclick。 由上可以看出View事件分发的顺序为： dispatchTouchEvent–&gt;onTouchListener–&gt;return false–&gt;onTouchEvent(). 如果View为disable则不执行onTouchlistener,执行onTouchEvent() onTouchEvent如果可点击出发onclick返回true消耗此次事件。 2.2 ViewGroup+View的事件分发跟View不同，ViewGroup跟touch的方法多了一个onInterceptTouchEvent()。并且执行顺序为dispatchTouchEvent(分发)–onInterceptTouchEvent(拦截)–onTouchEvent(处理)。 事件分发：public boolean dispatchTouchEvent(MotionEvent ev) return true:表示该View消费掉了事件 return false:交由上层控件onTouchEvent进行处理 return super:调用本层onInterceptTouchEvent()方法 结论：不管viewGroup返回true或者false事件都不会向下进行分发，区别在于true直接消费掉，false交由上层处理，只响应了ACTION_DOWN 事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev) return true:拦截此次事件，将事件交给onTouchEvent()进行处理 return false:不拦截，将此次事件传递给子控件，由子控件的dispatchTouchEvent进行处理 return super:和返回false一样，讲事件传递给子控件 事件处理：public boolean onTouchEvent(MotionEvent ev) return true:响应事件。 return false:不响应，交由上层控件的onTouchEvent return super.duspatchTouchEvent(ev),同false。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]